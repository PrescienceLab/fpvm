#!/usr/bin/env python3

import argparse
import shutil
from pathlib import Path
import os
import subprocess
import hashlib
# import lief # TODO
import time
import pandas as pd


CACHE_DIR = os.path.expanduser('~/.cache/fpvm')
SCRIPT_DIR = Path(os.path.realpath(os.path.dirname(__file__)))
FPVM_HOME = SCRIPT_DIR / '../' # TODO: this FPVM_HOME thing makes distribution later really annoying


WRAP_LIST = FPVM_HOME / 'wrap.list'

# First, attempt to find where FPVM is.
FPVM_LOCATION = None


fpvm_locations = [
    # Currently, only look in a few locations.

    # When developing...
    FPVM_HOME / 'build/fpvm.so',

    # When installed to $DIR, $DIR/bin and $DIR/lib are next to eachother, as is the case in nix
    FPVM_HOME / 'lib/fpvm.so', 
]

for loc in fpvm_locations:
    loc = os.path.realpath(os.path.expanduser(loc))
    if os.path.isfile(loc):
        FPVM_LOCATION = str(Path(loc).resolve())
        break


# Expand a binary path using PATH
def path_expand(binary):
  bin = shutil.which(binary)

  if bin is None:
    print(f'Could not find binary, {binary}')
    exit(-1)
  return bin




# The point of this class is to provide a way to get a temporary directory
# which is keyed to the content hash of input files or strings
class ContentHashDir:
  def __init__(self, name):
    self._hash = hashlib.sha1()
    self._name = name

  def file_input(self, path):
    self.string_input(f'FILE: {path}') # Just record that we hash a file
    with open(path, "rb") as f:
      # Read the file in chunks to avoid loading the entire file into memory
      chunk = 0
      while chunk := f.read(4096):
          self._hash.update(chunk)


  def string_input(self, s: str):
    self._hash.update(s.encode())


  def digest(self):
    return self._hash.hexdigest()

  # Create the directory on disk, and return a Path to it.
  def get(self, file=None):
    hash = self.digest()
    dir = os.path.expanduser(f'{CACHE_DIR}/{hash}-{self._name}')
    os.makedirs(dir, exist_ok=True)

    shutil.copy(FPVM_HOME/'.config', Path(dir)/'config')
    os.system(f'git -C {FPVM_HOME} rev-parse HEAD > {Path(dir) / "GIT"}')
    if file is not None:
      return Path(dir) / file
    return Path(dir)

  def exists(self, name):
    dir = self.get()
    return os.path.isfile(dir / name)

  def __truediv__(self, name):
    return self.get(name)





# Given a binary, return a full path to a patched version of it
# @binary: A path to the binary we are interested in
# @version: either 'magic' or 'trap'
def get_patched_binary(binary: Path, version: str='magic') -> Path:
  name = os.path.basename(binary)


  ch = ContentHashDir(f'patch-{name}')
  ch.file_input(binary) # The key is simply the file itself.

  if version not in ['magic', 'trap']:
    raise ValueError(f'Invalid version, {version}')

  magic = name + '.magic'
  trap = name + '.trap'

  if not ch.exists(trap) or not ch.exists(magic):
    # Generate the patch in right place.
    os.system(f'env FPVM_WRAP=disable fpvm_patch.sh -n -w {ch.get()} {binary} >&2')
    shutil.copy(ch.get('input.patched_magic'), ch.get(magic))
    shutil.copy(ch.get('input.patched_trap'), ch.get(trap))

  return ch.get(f'{name}.{version}')


def get_additional_wrappers(wrap_list: Path, mode: str = 'reverse') -> Path:
  ch = ContentHashDir(f'additional_wrappers_{mode}')
  ch.file_input(wrap_list)


  so = ch / 'wrappers.so'

  os.system(f'cd {ch.get()} && wrap_dynamic_calls_{mode}.pl {wrap_list} wrap')

  # Generate a c file which pulls it all together
  with open(ch / 'wrap.c', 'w') as f:
    f.write(f'#define _GNU_SOURCE\n')
    f.write(f'#include <dlfcn.h>\n')
    f.write(f'#include "{FPVM_HOME / "include/fpvm/fpvm_common.h"}"\n')
    f.write(f'#include "{ch / "wrap.h"}"\n')
    f.write(f'#include "{ch / "wrap.inc"}"\n')

  os.system(f'cd {ch.get()} && gcc -fPIC -shared -o {so} wrap.c wrap.S')

  return so




def get_wrapped_binary(binary: Path, version: str='magic', mode: str = 'reverse') -> Path:
  name = os.path.basename(binary)
  # The wrapped binary is keyed on the hash of the patched binary
  patched = get_patched_binary(binary, version)

  ch = ContentHashDir(f'{mode}-wrap-{name}')
  ch.file_input(patched)

  get_additional_wrappers(WRAP_LIST)

  if mode == 'reverse':
    if not ch.exists(name):
      os.system(f'fpvm_wrap -o {ch/name} -f {WRAP_LIST} {patched}')
    return ch.get(name)


  raise ValueError('We only support the reverse mode in the fpvm script for now')









# ===============================================================
# The following functions are callbacks from the argument parser:
# ===============================================================


# Run a binary with FPVM.
def cmd_run(args):
  bin = path_expand(args.binary)

  # Construct the environ the binary should be run with
  env = os.environ.copy() # Copy the current environment variables.
  env['LD_PRELOAD'] = args.fpvm + ' ' + str(get_additional_wrappers(WRAP_LIST)) # most importantly, setup FPVM's LD_PRELOAD
  bin = get_wrapped_binary(bin) # Patch the binary as needed
  cmd = subprocess.Popen([bin, *args.argv], env=env)
  cmd.wait()



# Patch a binary with FPVM and print out where it lives
def cmd_patch(args):
  bin = path_expand(args.binary)
  print(get_patched_binary(bin))


# Wrap a binary with FPVM and print out where it lives
def cmd_wrap(args):
  bin = path_expand(args.binary)
  print(get_wrapped_binary(bin, 'magic', args.mode))

def cmd_benchmark(args):
  bin = path_expand(args.binary)

  # Construct the environ the binary should be run with
  fpvm_env = os.environ.copy()
  fpvm_env['LD_PRELOAD'] = args.fpvm

  runs = [
    ('baseline', bin, os.environ.copy()),
    ('magic', get_wrapped_binary(bin, 'magic'), fpvm_env),
    ('trap', get_wrapped_binary(bin, 'trap'), fpvm_env),
  ]

  results = []

  for name, bin, env in runs:
    for run_idx in range(args.count):
      start = time.time()
      cmd = subprocess.Popen([bin, *args.argv], env=env, stdout=subprocess.DEVNULL)
      cmd.wait()
      end = time.time()

      results.append({'name': name, 'time': (end - start), 'run': run_idx})
  res = pd.DataFrame(results)

  base = res[res['name'] == 'baseline']['time'].mean()

  for name, _, _ in runs:
    if name == 'baseline':
      continue
    this = res[res['name'] == name]['time'].mean()
    print(f'{name}: slowdown={this / base:.2f}x')
  res.to_csv(args.output, index=False)


def clear_cache(args):
  # Simply delete where the cache is
  shutil.rmtree(CACHE_DIR, ignore_errors=True)





# ===============================================================
# Arg parsing and dispatch below:
# ===============================================================


parser = argparse.ArgumentParser(
  prog='FPVM',
  description='The floating point virtual machine')

parser.add_argument('--cachedir', help='Where the cache should be located', required=False, default=CACHE_DIR)
parser.add_argument('--fpvm', help='Path to FPVM', required=False, default=FPVM_LOCATION)
parser.add_argument('--wrap-list', help='The wrap list to use when generating wrappers', default=FPVM_HOME / 'wrap.list')

sub = parser.add_subparsers(required=True, title='action')

# The run subcommand
p = sub.add_parser('run', help='run a binary')
p.add_argument('-o', help='Optional argument')
p.add_argument('binary', help='Binary to run')
p.add_argument('argv', nargs=argparse.REMAINDER, help='Arguments to the binary')
p.set_defaults(func=cmd_run)

# The benchmark subcommand
p = sub.add_parser('benchmark', help='benchmark FPVM\'s overhead on a binary')
p.add_argument('-c', '--count', type=int, help='How many runs', default=1)
p.add_argument('-o', '--output', help='Destination for the CSV file', required=True)
p.add_argument('binary', help='Binary to run')
p.add_argument('argv', nargs=argparse.REMAINDER, help='Arguments to the binary')
p.set_defaults(func=cmd_benchmark)


# The patch subcommand
p = sub.add_parser('patch', help='patch a binary')
p.add_argument('-o', '--output', help='output binary', default='fpvm.out')
p.add_argument('binary', help='Binary to patch')
p.set_defaults(func=cmd_patch)


# The wrap subcommand
p = sub.add_parser('wrap', help='wrap the symbols in a binary')
p.add_argument('-o', '--output', help='output binary', default='fpvm.out')
p.add_argument('-m', '--mode', help='The wrap mode to use (forward/reverse)', default='reverse')
p.add_argument('-s', dest='symbols', default="", help="comma-seperated list of symbols")
p.add_argument('-f', '--from-file', help='file which contains a symbol on each line')
p.add_argument('binary', help='Binary to wrap')
p.set_defaults(func=cmd_wrap)

# The clear-cache command
p = sub.add_parser('clear-cache', help='Delete the FPVM cache directory')
p.set_defaults(func=clear_cache)

# Parse the commands
args = parser.parse_args()

if args.fpvm is None:
  print('Could not find an fpvm.so installed. Aborting')
  exit(-1)

# If fpvm is found (or provided), make it an absolute path
args.fpvm = os.path.realpath(args.fpvm)
FPVM_LOCATION = args.fpvm
WRAP_LIST = args.wrap_list
CACHE_DIR = os.path.realpath(os.path.expanduser(args.cachedir))

print(CACHE_DIR)


if hasattr(args, 'func'):
  args.func(args)

#!/usr/bin/env python3

import argparse
import shutil
from pathlib import Path
import os
import subprocess
import hashlib
# import lief # TODO
import time
import pandas as pd
import multiprocessing as mp
import resource
import re
import math


CACHE_DIR = os.path.expanduser('~/.cache/fpvm')
SCRIPT_DIR = Path(os.path.realpath(os.path.dirname(__file__)))
FPVM_HOME = SCRIPT_DIR / '../' # TODO: this FPVM_HOME thing makes distribution later really annoying

WRAP_LIST = FPVM_HOME / 'wrap.list'

# First, attempt to find where FPVM is.
FPVM_LOCATION = None



# TODO: these metrics should be changed to match the real world.
HW_TO_KERNEL_TIME=1000
KERNEL_TO_USER_TIME=1000
CALL_WRAP_TIME=40

fpvm_locations = [
    # Currently, only look in a few locations.

    # When developing...
    FPVM_HOME / 'build/fpvm.so',

    # When installed to $DIR, $DIR/bin and $DIR/lib are next to eachother, as is the case in nix
    FPVM_HOME / 'lib/fpvm.so', 
]

for loc in fpvm_locations:
    loc = os.path.realpath(os.path.expanduser(loc))
    if os.path.isfile(loc):
        FPVM_LOCATION = str(Path(loc).resolve())
        break


# Expand a binary path using PATH
def path_expand(binary):
  bin = shutil.which(binary)

  if bin is None:
    print(f'Could not find binary, {binary}')
    exit(-1)
  return bin




# The point of this class is to provide a way to get a temporary directory
# which is keyed to the content hash of input files or strings
class ContentHashDir:
  def __init__(self, name):
    self._hash = hashlib.sha1()
    self._name = name

  def file_input(self, path):
    self.string_input(f'FILE: {path}') # Just record that we hash a file
    with open(path, "rb") as f:
      # Read the file in chunks to avoid loading the entire file into memory
      chunk = 0
      while chunk := f.read(4096):
          self._hash.update(chunk)


  def string_input(self, s: str):
    self._hash.update(s.encode())


  def digest(self):
    return self._hash.hexdigest()

  # Create the directory on disk, and return a Path to it.
  def get(self, file=None):
    hash = self.digest()
    dir = os.path.expanduser(f'{CACHE_DIR}/{hash}-{self._name}')
    os.makedirs(dir, exist_ok=True)

    shutil.copy(FPVM_HOME/'.config', Path(dir)/'config')
    os.system(f'git -C {FPVM_HOME} rev-parse HEAD > {Path(dir) / "GIT"}')
    if file is not None:
      return Path(dir) / file
    return Path(dir)

  def exists(self, name):
    dir = self.get()
    return os.path.isfile(dir / name)

  def __truediv__(self, name):
    return self.get(name)





# Given a binary, return a full path to a patched version of it
# @binary: A path to the binary we are interested in
# @version: either 'magic' or 'trap'
def get_patched_binary(binary: Path, version: str='magic') -> Path:
  name = os.path.basename(binary)


  ch = ContentHashDir(f'patch-{name}')
  ch.file_input(binary) # The key is simply the file itself.

  if version not in ['magic', 'trap']:
    raise ValueError(f'Invalid version, {version}')

  magic = name + '.magic'
  trap = name + '.trap'

  if not ch.exists(trap) or not ch.exists(magic):
    # Generate the patch in right place.
    os.system(f'env FPVM_WRAP=disable fpvm_patch.sh -m -n -w {ch.get()} {binary} >&2')
    shutil.copy(ch.get('input.patched_magic'), ch.get(magic))
    shutil.copy(ch.get('input.patched_trap'), ch.get(trap))

  return ch.get(f'{name}.{version}')






def get_additional_wrappers(wrap_list: Path, mode: str = 'reverse') -> Path:
  ch = ContentHashDir(f'additional_wrappers_{mode}')
  ch.file_input(wrap_list)


  so = ch / 'wrappers.so'

  os.system(f'cd {ch.get()} && wrap_dynamic_calls_{mode}.pl {wrap_list} wrap')

  # Generate a c file which pulls it all together
  with open(ch / 'wrap.c', 'w') as f:
    f.write(f'#define _GNU_SOURCE\n')
    f.write(f'#include <dlfcn.h>\n')
    f.write(f'#include "{FPVM_HOME / "include/fpvm/fpvm_common.h"}"\n')
    f.write(f'#include "{ch / "wrap.h"}"\n')
    f.write(f'#include "{ch / "wrap.inc"}"\n')

  os.system(f'cd {ch.get()} && gcc -fPIC -shared -o {so} wrap.c wrap.S')

  return so




def get_wrapped_binary(binary: Path, version: str='magic', mode: str = 'reverse') -> Path:
  name = os.path.basename(binary)
  # The wrapped binary is keyed on the hash of the patched binary
  patched = get_patched_binary(binary, version)

  ch = ContentHashDir(f'{mode}-wrap-{name}')
  ch.file_input(patched)

  get_additional_wrappers(WRAP_LIST)

  if mode == 'reverse':
    if not ch.exists(name):
      os.system(f'fpvm_wrap -o {ch/name} -f {WRAP_LIST} {patched}')
    return ch.get(name)


  raise ValueError('We only support the reverse mode in the fpvm script for now')




def run_fpvm_binary(bin: Path,
                    args: list[str],
                    use_fpvm: bool=True,
                    logfile=None,
                    stdout=None,
                    stderr=None):
  # Called in a forked child where we can get rusage accurately
  def _run(bin: Path, args: list[str], send):
    usage = resource.getrusage(resource.RUSAGE_CHILDREN)

    env = os.environ.copy()
    if use_fpvm:
      env['LD_PRELOAD'] = str(FPVM_LOCATION) + ' ' + str(get_additional_wrappers(WRAP_LIST))
    if logfile is not None:
      env['FPVM_LOG_FILE'] = str(logfile)
    proc = subprocess.Popen(
        [bin, *args],
        stdout=stdout,
        stderr=stderr,
        env=env,
    )
    status = proc.wait()

    usage = resource.getrusage(resource.RUSAGE_CHILDREN)
    out = {}
    out["time"] = usage.ru_utime + usage.ru_stime
    out["stime"] = usage.ru_stime
    out["utime"] = usage.ru_utime
    out["major"] = usage.ru_majflt
    out["minor"] = usage.ru_minflt
    out["maxrss"] = usage.ru_maxrss
    out["status"] = status
    send.send(out)

  # Create a data pipe that we can send data over
  recv, send = mp.Pipe(False)
  # Then, create a subprocess which calls _run and has a fresh RUSAGE_CHILDREN
  p = mp.Process(target=_run, args=(bin, args, send))
  p.start() # Start the process
  p.join() # And wait for it to finish
  # Finally, receive the data it sends
  return recv.recv()




# ===============================================================
# The following functions are callbacks from the argument parser:
# ===============================================================


# Run a binary with FPVM.
def cmd_run(args):
  bin = path_expand(args.binary)
  if not args.baseline:
    # If we aren't running a baseline, wrap the binary
    bin = get_wrapped_binary(bin)

  # Run the binary...
  out = run_fpvm_binary(bin,
                        args.argv,
                        # stdout=subprocess.DEVNULL
                        use_fpvm=not args.baseline)
  print(out)



# Patch a binary with FPVM and print out where it lives
def cmd_patch(args):
  bin = path_expand(args.binary)
  print(get_patched_binary(bin))


# Wrap a binary with FPVM and print out where it lives
def cmd_wrap(args):
  bin = path_expand(args.binary)
  print(get_wrapped_binary(bin, 'magic', args.mode))










def get_telemetry(file: Path):
  t = {}
  with open(file) as f:
    for line in f:
      # Check if the line is even interesting
      m = re.match(r'^fpvm\s+info\(.*\):\s+telemetry:\s+(\S.*)$', line)
      if not m:
        continue
      # Cut the front off
      line = re.sub(r'^fpvm\s+info\(.*\):\s+telemetry:', '', line)

      for p in line.split(','):
        p = p.strip()
        p = re.sub(r'\(.*\)', '', p)
        match = re.match(r'^\d+', p)
        val = int(match.group())
        remainder = p[len(match.group()):].strip().replace(' ', '_')
        t[remainder] = val
  return t



def get_performance(file: Path):
  metrics = []
  with open(file) as f:
    for line in f:
      # Check if the line is even interesting
      m = re.match(r'^fpvm\s+info\(.*\):\s+perf:\s+(\S.*) :\s+(\S.*)$', line)
      if not m:
        continue
      line = re.sub(r'^fpvm\s+info\(.*\):\s+perf:', '', line).strip()
      bits = line.split(' : ')
      
      m = {}
      m['name'] = bits[0].replace(' ', '_').strip()

      for p in bits[1].split(' '):
        name, val = p.split('=')
        m[name] = float(val)

      # Copmute avg, stddev ourselves just in case
      if m['count'] == 0:
        m['avg'] = 0.0;
        m['std'] = 0.0;
        m['min'] = 0;
        m['max'] = 0;
      else:
        m['avg'] = m['sum'] / m['count']
        m['std'] = math.sqrt(m['sum2'] / m['count'] - m['avg']*m['avg'])
      metrics.append(m)
  return metrics


def div_clamp(a, b):
  if b != 0:
    return a / b
  return 0


def cmd_benchmark(args):
  bin = path_expand(args.binary)

  name = args.name or os.path.basename(bin)

  output = Path(args.output)
  # Make sure the result dir is valid
  os.makedirs(output, exist_ok=True)

  # Save the .config that FPVM was compiled with
  shutil.copy(FPVM_HOME/'.config', output/'config')
  # Save the git hash of the most recent commit
  os.system(f'git -C {FPVM_HOME} rev-parse HEAD > {output / "GIT"}')

  # Construct the environ the binary should be run with
  fpvm_env = os.environ.copy()
  fpvm_env['LD_PRELOAD'] = args.fpvm

  runs = [
    ('baseline', bin, os.environ.copy()),
    ('magic', get_wrapped_binary(bin, 'magic'), fpvm_env),
    # (f'{name}_trap', get_wrapped_binary(bin, 'trap'), fpvm_env),
  ]

  for run_name, bin, env in runs:
    usages = []
    amortized = []
    use_fpvm = run_name != 'baseline'
    for run_idx in range(args.count):
      log = output / f'{run_name}_{run_idx}.fpvm_log'
      print(f'Running {run_name}.{run_idx}')
      usage = run_fpvm_binary(bin,
                              args.argv,
                              use_fpvm=use_fpvm,
                              logfile=log,
                              stdout=subprocess.DEVNULL,
                              stderr=subprocess.DEVNULL)
      print(f'    time: {usage["time"]}s')
      with open(log, "a") as f:
        f.write(f'fpvm time: real {usage["time"]:.4f} user {usage["utime"]:.4f} sys {usage["stime"]:.4f}\n')


      # If this run is using FPVM, make sure to record telemetry, perf, and amortized metrics.
      if use_fpvm:
        t = get_telemetry(log)
        pd.DataFrame([t]).to_csv(output / f'{run_name}_{run_idx}_telem.csv', index=False)

        perf_metrics = get_performance(log)
        pd.DataFrame(perf_metrics).to_csv(output / f'{run_name}_{run_idx}_perf.csv', index=False)

        # Create a nicer version of the perf data for use here:
        perf = {}
        for metric in perf_metrics:
          perf[metric['name']] = metric

        amor = {}

        numfpe = t['fp_traps']
        numcor = t['correctness_traps']
        numfor = t['correctness_foreign_calls']
        numinst = t['instructions_emulated']

        amor['name'] = name
        amor['run'] = run_name
        amor['hw'] = div_clamp(HW_TO_KERNEL_TIME*numfpe,numinst);
        amor['kern'] = div_clamp(KERNEL_TO_USER_TIME*numfpe,numinst);
        amor['decache'] = div_clamp(perf['decode_cache']['sum'],numinst);
        amor['decode'] = div_clamp(perf['decoder']['sum'],numinst);
        amor['bind'] = div_clamp(perf['bind']['sum'],numinst);
        amor['emul'] = div_clamp(perf['emulate']['sum'],numinst);
        amor['gc'] = div_clamp(perf['garbage_collector']['sum'],numinst);
        amor['fcall'] = div_clamp(perf['foreign_call']['sum']+CALL_WRAP_TIME*numfor,numinst);
        amor['corr'] = div_clamp(perf['correctness']['sum']+(HW_TO_KERNEL_TIME+KERNEL_TO_USER_TIME)*numcor,numinst);
        amor['total'] = amor['hw']+amor['kern']+amor['decache']+amor['decode']+amor['bind']+amor['emul']+amor['gc']+amor['fcall']+amor['corr'];

        amortized.append(amor)

      usages.append(usage)


    if use_fpvm:
      pd.DataFrame(amortized).to_csv(output / f'{run_name}_amortized.csv', index=False)
    pd.DataFrame(usages).to_csv(output / f'{run_name}_rusage.csv', index=False)





def clear_cache(args):
  # Simply delete where the cache is
  shutil.rmtree(CACHE_DIR, ignore_errors=True)




# ===============================================================
# Arg parsing and dispatch below:
# ===============================================================


if __name__ == '__main__':

  parser = argparse.ArgumentParser(
    prog='FPVM',
    description='The floating point virtual machine')

  parser.add_argument('--cachedir', help='Where the cache should be located', required=False, default=CACHE_DIR)
  parser.add_argument('--fpvm', help='Path to FPVM', required=False, default=FPVM_LOCATION)
  parser.add_argument('--wrap-list', help='The wrap list to use when generating wrappers', default=FPVM_HOME / 'wrap.list')

  sub = parser.add_subparsers(required=True, title='action')

  # The run subcommand
  p = sub.add_parser('run', help='run a binary')
  p.add_argument('-o', help='Optional argument')
  p.add_argument('--baseline', help='Run the original binary w/ timing', action='store_true')
  p.add_argument('binary', help='Binary to run')
  p.add_argument('argv', nargs=argparse.REMAINDER, help='Arguments to the binary')
  p.set_defaults(func=cmd_run)

  # The benchmark subcommand
  p = sub.add_parser('benchmark', help='benchmark FPVM\'s overhead on a binary')
  p.add_argument('-c', '--count', type=int, help='How many runs', default=1)
  p.add_argument('--name', type=str, help='Name of the benchmark run (Defaults to the name of the binary)')
  p.add_argument('-o', '--output', help='Directory where outputs should be written', required=True)
  p.add_argument('binary', help='Binary to run')
  p.add_argument('argv', nargs=argparse.REMAINDER, help='Arguments to the binary')
  p.set_defaults(func=cmd_benchmark)


  # The patch subcommand
  p = sub.add_parser('patch', help='patch a binary')
  p.add_argument('-o', '--output', help='output binary', default='fpvm.out')
  p.add_argument('binary', help='Binary to patch')
  p.set_defaults(func=cmd_patch)


  # The wrap subcommand
  p = sub.add_parser('wrap', help='wrap the symbols in a binary')
  p.add_argument('-o', '--output', help='output binary', default='fpvm.out')
  p.add_argument('-m', '--mode', help='The wrap mode to use (forward/reverse)', default='reverse')
  p.add_argument('-s', dest='symbols', default="", help="comma-seperated list of symbols")
  p.add_argument('-f', '--from-file', help='file which contains a symbol on each line')
  p.add_argument('binary', help='Binary to wrap')
  p.set_defaults(func=cmd_wrap)

  # The clear-cache command
  p = sub.add_parser('clear-cache', help='Delete the FPVM cache directory')
  p.set_defaults(func=clear_cache)

  # Parse the commands
  args = parser.parse_args()

  if args.fpvm is None:
    print('Could not find an fpvm.so installed. Aborting')
    exit(-1)

  # If fpvm is found (or provided), make it an absolute path
  args.fpvm = os.path.realpath(args.fpvm)
  FPVM_LOCATION = args.fpvm
  WRAP_LIST = args.wrap_list
  CACHE_DIR = os.path.realpath(os.path.expanduser(args.cachedir))


  if hasattr(args, 'func'):
    args.func(args)

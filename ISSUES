Benchmarks

(works does not mean sequence emulation is working properly)

Main branch:
lorenz        - works, validates
double-pend   - works, validates
3body         - works, validates
fbench        - works, validates
ffbench       - works, validates
miniaero      - ? 
enzo          - ?
lbm           - ?
nas-mg        - works, validates, mysterious issues (YIKES) vector instructions in 
nas-bt        - works, validates, mysterious vector instructions
nas-sp        - SEGFAULT   
nas-lu        - ASSERTION FAILURE (correctness handler failed)  vector instruction and bogus instructions for correctness
                movsxd instruction
nas-ft        - ASSERTION FAILURE - movsxd instruction
nas-is        - works, validates
nas-cg        - works, does not validate, no errors shown (-nan outputs)
nas-ep        - SEGFAULT (after one emul of mulsd in correctness


State: need to xform miniaero, enzo, lbm;  need to investigate segfaults / movsxd

fix_seq:

lorenz        - works, validates
double-pend   - works, validates
3body         - crashes with cmplt ?how
fbench        - works, validates
ffbench       - fpvm ERROR( 1872468): Cannot decode instruction 0 (rip 0x401926) of sequence:  cmpnlesd		xmm2, xmm0 (5 bytes)
miniaero      - ? 
enzo          - ?
lbm           - ?
nas-mg        - works, validates, mysterious issues (YIKES) vector instructions in 
nas-bt        - SEGFAULT
nas-sp        - SEGFAULT   
nas-lu        - ASSERTION FAILURE (correctness handler failed)  vector instruction and bogus instructions for correctness
                movsxd instruction
nas-ft        - ASSERTION FAILURE - movsxd instruction
nas-is        - works, validates
nas-cg        - works, does not validate, no errors shown (-nan outputs)
nas-ep        - SEGFAULT (after one emul of mulsd in correctness

State:
   miniaero : xformed, 
   lbm      : xformed, running
   enzo     : xformed, missing command line to run




Nadharm:
hw->kernel was ~200
kernel->user is ~478 for kmod and ~1950 for normal

===============================================================
DONE - if we always generate an SNaN for encoding, we are fine
  - how to handle comparisons that do not fault
     possibly add a whole system patcher a la vmware

  COMISD - faults on SNan or Qnan
  UCOMISD - faults on SNan

  These shouold be fine, but there may be others
===============================================================

===============================================================
- Need to verify correct behavior for conversion operations 

Note that f2i is only overwriting the part of the register target
that is get the output.   This probably should handle zeroing the
rest of the register in case this is the excepted behavior (not sure)
===============================================================

===============================================================
CMPLT and similar

- these instructions should be emulatable.   The main
  deal is that they do a *specific* comparison and then
  set the destiation register to all 1s or all 0s

===============================================================


===============================================================
DONE - Clearly document the compilation/etc technique that Alex found
  for forcing only SSE2 or other limits
===============================================================


===============================================================
Instructions that the analysis should catch:

Instructions that move from xmm to gpr, such as:

movmskpd        eax, xmm0  [intel format]
movq            xmm0, %rax [at&t format]

These should be demotions via temporary

===============================================================
Instructions analysis should NOT catch, but currently is:

problematic correctness instr (YIKES): mulsd		xmm3, xmm7 (4 bytes)

purely register/register, where the dest is not a gpr


problematic correctness instr: subpd		xmm0, xmm1 (4 bytes)
problematic correctness instr (YIKES): subpd		xmm0, xmm1 (4 bytes)
problematic correctness instr (YIKES): mulsd		xmm3, xmm2 (4 bytes)

===============================================================



========

Instructions that should be emulated ok, but...


BT
problematic correctness instr: movups		xmmword ptr [rax + 0x4e5328], xmm4 (7 bytes)
problematic correctness instr (YIKES): movups		xmmword ptr [rax + 0x4e5328], xmm4 (7 bytes)
fpvm ERROR( 1518726): problematic instruction is vector instruction - ATTEMPTING EMULATION, WHICH IS LIKELY BOGUS


========


Paritally done:

sequence emulation now is getting O(2) instructions / trap instead
of O(32) / trap

fix_seq branch has relevant fixes, though some other things break
The issue was not so much the seq emulation, but the changes
to the sign handling - bugs in GC, nan-boxing, and in alt/boxed


